## 接口与数据模型确认
- 区域页面项目布局（POST ` /layout/{region}` → `list[LayoutProjectRead]`）
  - `project_id:int`、`project_name:str`、`start_point_ratio:float`、`project_ratio:float`
  - 请求体 `LayoutProject`：`project_id_list:list[int]`、`main_start_time:datetime`、`main_end_time:datetime`
- 项目页面员工布局（GET ` /layout/{project_id}` → `list[LayoutRead]`）
  - `id:int`、`name:str`、`start_point_ratio:float`、`ratio:float`

## 前端数据流改造
- 区域页面（主时间轴驱动）
  1. 用户设置主时间轴 `main_start`、`main_end`（Date/ISO）
  2. 触发项目过滤（使用现有过滤接口或本地筛选），得到 `project_id_list`
  3. 组装请求体 `LayoutProject = { project_id_list, main_start_time, main_end_time }`
  4. 调用 `POST /layout/{region}`，获取 `list[LayoutProjectRead]`
  5. 将每个项目映射为渲染条：`left = start_point_ratio * containerWidth`、`width = project_ratio * containerWidth`
  6. 采用车道式布局算法进行排布，更新视图
- 项目页面（项目时间轴驱动）
  1. 加载项目详情（包含 `start_time`、`end_time`）
  2. 调用 `GET /layout/{project_id}`，获取 `list[LayoutRead]`
  3. 将每位员工条目映射为渲染条：`left = start_point_ratio * containerWidth`、`width = ratio * containerWidth`
  4. 使用车道式布局避免重叠，更新视图

## 布局渲染计算
- 统一归一化：将屏幕宽度视为 1，再映射到实际像素
  - `pxLeft = Math.round(start_point_ratio * W)`、`pxWidth = Math.round(ratio * W)`
  - 条件：`0 ≤ start_point_ratio ≤ 1`，`0 ≤ ratio ≤ 1`，`start + width ≤ W`
- 车道分配算法（贪心）
  - 维护 `lanes: number[]`，记录每条车道的“占据到”的最右边界（比例）
  - 对每个条目（按 `start_point_ratio` 升序）：找到第一个满足 `start_point_ratio ≥ lanes[i]` 的车道；若无则新建车道
  - 车道高度固定，`top = laneIndex * laneHeight`，`height = laneHeight`
- 组件与样式
  - 条形元素绝对定位：`style={{ left:pxLeft, width:pxWidth, top, height }}`
  - 容器监听 `resize`，动态更新 `W`

## 自动响应与流程编排
- 事件源
  - 主时间轴变化：防抖 300ms，重新过滤项目 → 重新调用布局接口 → 重排
  - 区域切换：重新获取项目列表与布局参数 → 重排
  - 项目页面加载/刷新：调用员工布局接口 → 重排
- 数据提取与构造
  - 过滤响应中提取 `project_id_list`
  - 保留之前的泳道（车道）式布局设计，只是宽度与位置改用后端参数

## 错误与边界处理
- 后端返回为空：清空布局并提示“无数据”
- 时间无交集：`ratio=0`，不渲染或渲染最小占位
- 越界：对比例进行 `clamp(0,1)`，并在日志中记录异常数据
- 网络错误：重试策略（最多 3 次，指数退避）；失败后显示错误态

## 字段一致性与对齐建议
- `LayoutProjectRead` 字段名使用 `project_ratio`；请确保后端响应键名与模型一致（若当前为 `layout_ratio`，需要后端调整或前端做键名映射）
- 前端统一使用：项目页面用 `ratio` 字段，区域页面用 `project_ratio` 字段

## 测试计划
- 单元测试
  - 比例到像素映射函数：边界、四舍五入、容器宽度变更
  - 车道分配：重叠与非重叠、极端密集数据
- 集成测试
  - 主时间轴变更 → 过滤 → 布局接口 → 渲染链路
  - 区域切换与项目页面加载的完整链路
- 端到端测试
  - 真实交互下的重排与渲染正确性（视图截图比对）

## 交付步骤
1. 新增前端 API 客户端：`getProjectLayout(projectId)`、`postRegionLayout(region, payload)`
2. 改造状态流与事件流：主时间轴/区域/项目页面的触发逻辑
3. 实现比例到像素映射与车道分配工具函数
4. 替换前端旧有本地计算逻辑，改用后端参数
5. 编写测试与回归验证
6. 验收后移除旧计算代码与相关配置